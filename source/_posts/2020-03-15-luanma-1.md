---
layout: post
title: Web应用中文乱码实验（一）：乱码现象概述
category: 闲谈
tags:
- 乱码
---
编码转换和乱码问题令人头大。在理清编码问题之前，需要先认识一下各种乱码的样子。
<!-- more -->

# 说明
为方便讨论与理解，本系列文章会故意忽略一些不太要紧的细节，甚至把一些事情说错。要知道，有些事情吧，它确实不是那回事，但是，我们的目的不是写一篇内容准确的学术论文，而是识别出一些软件开发过程中的坑，免得在字符编码方面把自己绕进去，浪费时间，所以你当作是那回事就行了。

欲知乱码背后的真相，请用Google搜索其他资料，并且别忘了找一款二进制编辑器来观察文件内部编码。

## 关于GB2312/GBK/GB18030
* 中华人民共和国最新的国家标准是GB18030
* 先前所用标准是GB2312
* 另外一个不属于国家标准但常用的编码是GBK，相当于一个事实上的标准。

由于这三个编码大体上是向下兼容的，在本系列文章中，我们会忽略[它们的内部差异](https://www.zhihu.com/question/19677619)，统一称为GBK。

## Java的默认编码
Java的默认编码比较坑，它和操作系统有关系。我们需要先按照以下方式来理解它的默认编码：
* Windows系统默认使用GBK编码，Java字符串内部也是GBK
* Linux/Mac系统默认使用UTF-8编码，Java字符串内部同样是UTF-8

以上只是一种理解方式。实际上，Java内部（版本9之前）使用UTF-16 LE存储字符串，而getBytes()时才会参考JVM启动参数`-Dfile.encoding`（没有的话就看操作系统环境），并且这个转换过程是透明的，我们感知不到。

# 编码类型
让我们看一下各种默认编码：

<small style="letter-spacing: -1pt;">
中国大陆标准是GBK；
Linux系统/Mac系统通常使用UTF-8编码；
（中国大陆的）Windows系统与程序通常使用GBK编码；
Java内部使用UTF-16编码；
在Windows中UTF-8还有带BOM头和不带BOM头的版本；
在Linux/Mac系统中，可将Java内部存储的字符串视为UTF-8；
在Windows系统中，需要将Java内部存储视为GBK；
Tomcat默认使用ISO-8859-1编码；
URL根据场合不同分别使用了GBK与UTF-8编码；
MySQL默认使用latin1；
日本Galgame经常使用Shift-JIS编码；
emoji（表情符号😂）需要使用UTF-8编码……
</small>

以上看起来很乱，而且确实很乱——真·乱码。

为了避免字符编码的坑，**如果你的系统尚未投入正式开发，请把所有编码统一成UTF-8！**

* 另外需注意，MySQL是`utf8mb4`，不是那个有坑的`utf8`！

如果系统已经上线，而且用了GBK编码，那就祈祷上线之前做过充分测试，然后用生僻字起名的人也没来找茬吧。

# 如何理解乱码
## 产生原因
以“这是一段LuanMa乱码”为例。

用UTF-8编码（忽略BOM头）存储的话，文件内容是这样的：
```
e8 bf 99 e6 98 af e4 b8 80 e6 ae b5 4c 75 61 6e 4d 61 e4 b9 b1 e7 a0 81
-------- -------- -------- --------                   -------- --------
   这       是        一       段    L  u  a  n  M  a     乱       码
```

用GBK编码存储的话，文件内容是这样的：
```
d5 e2 ca c7 d2 bb b6 ce 4c 75 61 6e 4d 61 c2 d2 c2 eb
----- ----- ----- -----                   ----- -----
  这    是    一    段   L  u  a  n  M  a    乱    码
```

如果内部是UTF-8，却按GBK编码处理，那么乱码就来了：
```
e8 bf 99 e6 98 af e4 b8 ...
----- ----- ----- ----- 
  杩    欐    槸     涓   ...
```

如果内部按GBK存储，却按UTF-8处理，结果也一样：
```
d5   e2   ca  c7  d2 bb  b6   ce  4c ...
--   --   --  --  -----  --   --  -- 
错误 错误 错误 错误    һ   错误 错误  L
```
其中的“错误”表示无法按编码规则解析，会变成黑色菱形问号`�`(`ef bf bd`)。出现黑菱形的时候，数据就已经被破坏了。

## 回答两个问题
在看到乱码时，问自己两个问题：
* 【原始字符串】的内部存储用了什么编码？
* 看到乱码的时候，是【谁】按照【哪种编码】【解析】了字符串的内部存储？

无论是读取、写入还是传输，只要碰到乱码，就用这两个问题来询问自己，然后事情就会清楚一些。

## 一些案例
举一些Java（在Linux/Mac上运行）的案例：

```java
String strNew = new String(str.getBytes("GBK"), "UTF-8");
```
* 我们假设原始字符串str的内部存储用了GBK编码。
* 【我们】按【UTF-8编码】【解析】了字符串str的内部存储。这样解析是错的，所以当然会产生乱码，程序代码也不应该这样写。

&nbsp;

```java
String strNew = new String(str.getBytes("GBK"), "GBK");
```
* 我们假设原始字符串str的内部存储用了GBK编码。
* 我们按【GBK编码】【解析】了字符串str的内部存储。
    * *这样解析是对的，但是有意义吗？有，在Linux系统中Java内部用UTF-8存储字符串，这样实际上就把GBK内部存储无损地转成UTF-8内部存储了。*

&nbsp;

```java
String strNew = new String(str.getBytes("ISO-8859-1"), "UTF-8");
```

* 我们假设原始字符串str的内部存储用了ISO-8859-1编码。
* 【我们】按【UTF-8编码】【解析】了字符串str的内部存储，并保存到strNew中。
    * *理论上讲这样实现是错的，但是，由于用ISO-8859-1编码相当于使用原始的二进制存储，所以，只要原始二进制存储是按UTF-8存储的，这条语句就不会丢失数据，也不会产生乱码。*

&nbsp;

```java
request.setCharacterEncoding("GBK");
```
* 我们假设原始字符串（原始请求）的内部存储用了GBK编码。
    * *怎么用了GBK编码呢？`<meta charset="GBK">`*
* 用户提交表单，向服务器发送请求时，让【request对象】按【GBK编码】【解析】原始请求。
    * *Tomcat呢？先假设它的配置是对的，没做过任何转换。*

&nbsp;

```java
response.setCharacterEncoding("GBK");
```
* 要求response在内部存储使用GBK编码。
* 要求浏览器按GBK解析请求返回结果的内部存储。

&nbsp;

先这样理解，后续有机会再详细讨论这些事。

# 乱码现象
我们再认识一下各种乱码的样子，以后看到乱码之后大概就能猜测乱码原因了。

原文：这是一段LuanMa乱码

## 一次转换
 现象描述  | 内容                              | 这说明原文的内部存储是哪种编码 | 按哪种编码解析了 | 乱码内容的内部存储            | 备注
----------|----------------------------------|----------------------------|---------------|-----------------------|----------------
 火星文    | 杩欐槸涓€娈礚uanMa涔辩爜            | UTF-8                     | GBK           | e8 bf 99 e6 98 af e4 b8 3f e6 ae b5 4c 75 61 6e 4d 61 e4 b9 b1 e7 a0 81 | 可以恢复大部分数据，但有损失（`3f`）
 黑色菱形问号 | ����һ��LuanMa����                | GBK                       | UTF-8         | ef bf bd ef bf bd ef bf bd ef bf bd d2 bb ef bf bd ef bf bd 4c 75 61 6e 4d 61 ef bf bd ef bf bd ef bf bd ef bf bd | `ef bf bd`即无法解析时产生的“无效码”，无法恢复数据
 稀疏的拉丁字母 | è¿æ¯ä¸æ®µLuanMaä¹±ç  | UTF-8       | ISO-8859-1           | e8 bf 99 e6 98 af e4 b8 80 e6 ae b5 4c 75 61 6e 4d 61 e4 b9 b1 e7 a0 81 | 可以完整恢复数据
 稠密的拉丁字母 | ÕâÊÇÒ»¶ÎLuanMaÂÒÂë        | GBK       | ISO-8859-1             | d5 e2 ca c7 d2 bb b6 ce 4c 75 61 6e 4d 61 c2 d2 c2 eb | 可以完整恢复数据
 问号      | ????LuanMa??                      | GBK / UTF-8       | ISO-8859-1      | 3f 3f 3f 3f 4c 75 61 6e 4d 61 3f 3f | 原始字符串就没有汉字，所以不可能恢复数据

## 二次转换（A→B→A）
在字符编码方面，“负负”叠加，结果不一定是“正”：

 现象描述  | 内容                           | 原始字符串的内部存储 | 你按哪种编码解析了 | 你又转换成了哪种编码 
----------|-------------------------------|-------------------|-----------------|----------------------
 锟斤拷    | 锟斤拷锟斤拷一锟斤拷LuanMa锟斤拷锟斤拷 | GBK           | UTF-8           | GBK
 丢个别文字 | 这是�?段LuanMa乱码             | UTF-8             | GBK             | UTF-8

出现“锟斤拷”，是因为按UTF-8编码规则，解析内部存储是GBK的字符串时，部分字节无法解析，程序按照规范将那些无法解析的字节换成了`ef bf bd`。再将这串内容转回GBK时，就变成了“锟”（GBK：`ef bf`）或者“锟斤拷”（GBK：`ef bf   bd ef   bf bd`）。

出现“？”同样是因为按GBK编码规则无法解析，结果用“?”（`3f`）替代了。

“锟斤拷”或“?”都说明信息已经丢失，就算手持两把锟斤拷，口中疾呼烫烫烫，原始数据也找不回来了。由此可见，处理UTF-8和GBK两种编码时，必须把原始字符串的编码弄对，否则互转会丢失信息。

## 二次转换（A→B→B）
如果已经做过A→B的转换，你对此不知情，又做了一遍A→B的转换：

 现象描述 | 内容                            | A→B中的A  | A→B中的B
---------|--------------------------------|-----------|-----------
 火星文   | 鏉╂瑦妲告稉锟藉▓绀歶anMa娑旇京鐖�  | UTF-8     | GBK
 ???     | ???????LuanMa????              | GBK       | UTF-8

可以看到，无论是ABA，还是ABB，二次转换都会让乱码更乱。

遇到乱码，我们应该要做的是理清“内部存储是哪种编码”和“用哪种编码解析的”，而不是粗暴地再进行一遍转码。

# 不一定是乱码的乱码
还有一种乱码，俗称“麻将牌”，样式为一个方块里面写入了几个数字。这个不一定是乱码，有可能只是电脑系统缺字体。

把字体装好之后，如果麻将牌变成了火星文，那么才是真乱码，后续按火星文处理方式处理即可。

# 参考资料
* [关于URL编码](https://www.ruanyifeng.com/blog/2010/02/url_encoding.html)
* [GBK与UTF-8编码错误转换后，无法再正确恢复](https://germinate.github.io/2016/GBK%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81%E9%94%99%E8%AF%AF%E8%BD%AC%E6%8D%A2%E5%90%8E%EF%BC%8C%E6%97%A0%E6%B3%95%E6%81%A2%E5%A4%8D/)

# 本系列文章
* **乱码现象概述**
* URL中文乱码测试
* Tomcat中文乱码测试
* MySQL中文乱码测试
* 补救措施
